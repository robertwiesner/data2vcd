diff --git a/src/Makefile b/src/Makefile
index 2f6ddad..8598079 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -12,4 +12,4 @@ libdata2vcd.so: $(OBJ)
 
 clean:
 	-rm $(OBJ)
-	-rm libdata2vcd.so
\ No newline at end of file
+	-rm data2vcd.a
diff --git a/src/cbitfield.cpp b/src/cbitfield.cpp
index 72cfa01..5be4aa4 100644
--- a/src/cbitfield.cpp
+++ b/src/cbitfield.cpp
@@ -21,7 +21,7 @@ under the License.
 
 #include "cbitfield.h"
 
-cBitfield::cBitfield(cJSONbase *pJSON)
+cBitfield::cBitfield(cJSONbase *pJSON, cOutput &rO) : rOutput(rO)
 {
     pFirst = createModule(0, pJSON, 0);
 }
@@ -29,9 +29,32 @@ cBitfield::cBitfield(cJSONbase *pJSON)
 
 cBitfield::~cBitfield()
 {
+    rOutput.finish();
+}
+
+void
+cBitfield::printHeader(const char *pPrefix)
+{
+    getFirstModule()->printHeader(&rOutput, pPrefix);
+}
+
+void
+cBitfield::setTime(unsigned long long tim)
+{
+    rOutput.setTime(tim);
+}
 
+void
+cBitfield::flush()
+{
+    rOutput.flush();
 }
 
+void
+cBitfield::finish()
+{
+    rOutput.finish();
+}
 
 cModule *
 cBitfield::createModule(cModule *pParent, cJSONbase *pBase, unsigned long long modIdx)
@@ -51,31 +74,51 @@ cBitfield::createModule(cModule *pParent, cJSONbase *pBase, unsigned long long m
                 cJSONscalar *pIdx = dynamic_cast<cJSONscalar *>(pIndex->getValue("<idx>"));
                 int newModIdx = modIdx + (pIdx ? pIdx->getValue() : 0);
                 pMod = new cModule(pNodeObj->getName(), pParent, pMod);
-                entry[newModIdx] = new sModWireInfo(pMod);
+                entry[newModIdx]   = new sModWireInfo(pMod);
+                module2index[pMod] = newModIdx;
                 createModule(pMod, pNodeObj->getValue(), newModIdx);
             }
         } else if (0 == strcmp(pO->getName(), "<ref>")) {
-            cJSONobject *pNode = dynamic_cast<cJSONobject *>(pBase->getParent()->getParent());
             cJSONstring *pRef  = dynamic_cast<cJSONstring *>(pO->getValue());
 
-            if (pRef && pNode) {
-                cJSONobj *pNodeObj = pNode->getObj(pRef->getValue());
-                createModule(pParent, pNodeObj->getValue(), modIdx);
+            if (pRef) {
+                cJSONbase *pNode = pV->search(pRef->getValue());
+                createModule(pParent, pNode, modIdx);
             }
         } else if (0 == strcmp(pO->getName(), "<wire>")) {
             // create Wires for the parent module
             int wireIdx = 0;
+            unsigned long long bitStart  = 0;
+            unsigned long long bitLength = 0;
             cJSONobject *pWireList = dynamic_cast<cJSONobject *>(pO->getValue());
             cJSONobj *pWireObj;
 
             while (0 != (pWireObj = pWireList->getObj(wireIdx++))) {
                 cJSONobject *pWire = dynamic_cast<cJSONobject *>(pWireObj->getValue());
                 cWire *pW;
-                int start = dynamic_cast<cJSONscalar *>(pWire->getValue("start"))->getValue();
-                int end   = dynamic_cast<cJSONscalar *>(pWire->getValue("end"))->getValue();
-                pW = new cWire(eWT_BIT, end - start + 1, pWireObj->getName());
+                cJSONscalar *pStart = dynamic_cast<cJSONscalar *>(pWire->getValue("start"));
+                cJSONscalar *pLen = dynamic_cast<cJSONscalar *>(pWire->getValue("len"));
+                cJSONscalar *pEnd = dynamic_cast<cJSONscalar *>(pWire->getValue("end"));
+
+                bitStart = pStart ? pStart->getValue() : bitStart;
+
+                if (pLen) {
+                    if (pEnd) {
+                        // later error handling
+                    }
+                    bitLength = pLen->getValue();
+                } else if (pEnd) {
+                    unsigned long long bitEnd = pEnd->getValue();
+                    if (bitEnd < bitStart) {
+                        // later error 
+                    }
+                    bitLength = bitEnd - bitStart + 1;
+                }
+
+                pW = new cWire(eWT_BIT, bitLength, pWireObj->getName());
                 pParent->addWire(pW);
-                entry[modIdx]->wires[start] = pW;
+                entry[modIdx]->wires[bitStart] = pW;
+                bitStart += bitLength;
             }
 
         } else {
diff --git a/src/cbitfield.h b/src/cbitfield.h
index 7853280..176e095 100644
--- a/src/cbitfield.h
+++ b/src/cbitfield.h
@@ -27,21 +27,42 @@ under the License.
 #include "cjson.h"
 #include "cmodule.h"
 #include "cwire.h"
+#include <string>
+#include "coutput.h"
 
 class cBitfield {
+    cOutput &rOutput;
     cModule *pFirst;
     struct sModWireInfo {
-        cModule *pMod;
-        std::map<int, cWire *>wires;
-        sModWireInfo(cModule *pM) { pMod = pM; }
+      cModule *pMod;
+      std::map<int, cWire *>wires;
+      sModWireInfo(cModule *pM) { pMod = pM; }
     };
     std::map<unsigned long long, sModWireInfo *>entry;
+    std::map<cModule *, unsigned long long>module2index;
     cModule *createModule(cModule *pParent, cJSONbase *, unsigned long long);
     public:
-    cBitfield(cJSONbase *pJSON);
+    cBitfield(cJSONbase *pJSON, cOutput &rO);
     ~cBitfield();
-    void updateValue(unsigned long long id, int size, const char *pPtr);
+    void printHeader(const char *pPrefix);
+    void setTime(unsigned long long);
+    void updateValue(unsigned long long id, int bitSize, const char *pPtr);
+
+    void updateValue(cModule *pMod, int bitSize, const char *pPtr) {
+      std::map<cModule *, unsigned long long>::iterator it = module2index.find(pMod);
+      if (it != module2index.end()) {
+        updateValue(it->second, bitSize, pPtr);
+      }
+    }
+
+    void updateValue(const char *pName, int bitSize, const char *pPtr) {
+      cModule *pMod = pFirst->searchModule(pName);
+      updateValue(pMod, bitSize, pPtr);
+    }
     cModule *getFirstModule() { return pFirst; }
+
+    void flush();
+    void finish();
 };
 
 #endif
\ No newline at end of file
diff --git a/src/cjson.cpp b/src/cjson.cpp
index 5a2e6d5..68838bc 100644
--- a/src/cjson.cpp
+++ b/src/cjson.cpp
@@ -21,6 +21,56 @@ under the License.
 
 #include "cjson.h"
 
+
+cJSONbase *cJSONbase::searchArray(const char *pStr)
+{
+    cJSONarray *pArr = dynamic_cast<cJSONarray *>(this);
+
+    if (pArr) {
+        char *pEnd = 0;
+        int idx = strtol(pStr, &pEnd, 0);
+
+        if (pEnd && *pEnd == ']') {
+            cJSONbase *pRet = pArr->getValue(idx);
+
+            if (pRet) {
+                switch (pEnd[1]) {
+                case '/': return pRet->search(pEnd + 2);
+                case 0  : return pRet;
+                default: return 0;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+cJSONbase *cJSONbase::searchObject(const char *pStr)
+{
+    cJSONobject *pObj = dynamic_cast<cJSONobject *>(this);
+
+    if (pObj) {
+        char aBuffer[1024];
+        char *pName = aBuffer;
+
+        while (*pStr && *pStr != '/' && *pStr != '[' && pName != (aBuffer + sizeof(aBuffer) - 1) ) {
+            *pName++ = *pStr++;
+        }
+        *pName = 0;
+
+        cJSONbase *pRet = pObj->getValue(aBuffer);
+        if (pRet) {
+            switch(*pStr) {
+            case '/': return pRet->search(pStr + 1);
+            case '[': return pRet->search(pStr);
+            case 0: return pRet;
+            default: return 0;
+            }
+        }
+    }
+    return 0;
+}
+
 cJSONbase *
 cJSONbase::generate(cJSONbase *pP, FILE *pIn)
 {
diff --git a/src/cjson.h b/src/cjson.h
index 8eb8593..41e0fd6 100644
--- a/src/cjson.h
+++ b/src/cjson.h
@@ -41,6 +41,8 @@ class cJSONbase {
     cJSONbase *pParent;
     eJSONtype type;
 
+    cJSONbase *searchArray(const char *pStr);
+    cJSONbase *searchObject(const char *pStr);
     public:
     cJSONbase(eJSONtype t, cJSONbase *pP) {
         pParent = pP;
@@ -56,6 +58,43 @@ class cJSONbase {
 
     cJSONbase *getParent() { return this ? pParent : 0; }
 
+    cJSONbase *search(const char *pStr) {
+        cJSONbase *pRet = this;
+        switch (pStr[0]) {
+        case 0:
+            return this;
+
+        case '/':
+            while (pRet->pParent) {
+                pRet = pRet->pParent;
+            }
+            return pRet->search(pStr+1);
+
+        case '.':
+            switch (pStr[1]) {
+            case '.':
+                pRet = pRet->pParent;
+                if (pStr[2] == '/') {
+                    return pRet ? pRet->search(pStr+3) : NULL;
+                } else if (pStr[2] == 0) {
+                    return pRet;
+                }
+                return NULL;
+            case '/':
+                return pRet->search(pStr+2);
+            case 0:
+                return pRet;
+            default:
+                return NULL;
+            }
+        case '[':
+            return searchArray(pStr);
+
+        default:
+            return searchObject(pStr);
+        }
+    }
+
     virtual char *toStr(int &rLen, char *pBuffer) = 0;
     virtual char *fromStr(char *pBuffer) = 0;
 
@@ -231,7 +270,7 @@ class cJSONobject : public cJSONbase {
         }
         return -1;
     }
-    int getIndex(std::string s) {
+    int getIndex(std::string &s) {
         for (size_t idx = 0; idx < value.size(); idx++) {
             if (value[idx]->checkName(s)) {
                 return idx;
@@ -271,15 +310,27 @@ class cJSONobject : public cJSONbase {
     }
 
     cJSONbase *getValue(const char *s) {
-        return getObj(getIndex(s))->getValue();
+        cJSONobj *pO = getObj(getIndex(s));
+        return pO ? pO->getValue() : NULL;
+    }
+
+    cJSONbase *getValue(std::string &s) {
+        cJSONobj *pO = getObj(getIndex(s));
+        return pO ? pO->getValue() : NULL;
     }
 
     void setValue(const char *s, cJSONbase *v) {
-        getObj(getIndex(s))->setValue(v);
+        cJSONobj *pO = getObj(getIndex(s));
+        if (pO) {
+            pO->setValue(v);
+        }
     }
 
-    void setValue(std::string s, cJSONbase *v) {
-        getObj(getIndex(s))->setValue(v);
+    void setValue(std::string &s, cJSONbase *v) {
+        cJSONobj *pO = getObj(getIndex(s));
+        if (pO) {
+            pO->setValue(v);
+        }
     }
 
     char *toStr(int &rLen, char *pBuffer);
diff --git a/src/cmodule.h b/src/cmodule.h
index b48d54b..ca24738 100644
--- a/src/cmodule.h
+++ b/src/cmodule.h
@@ -41,8 +41,12 @@ class cModule {
         depth = parent ? parent->depth + 1: 0;
         name = pName;
         pParent = parent;
-        if (parent && parent->pChildren == NULL) {
-            parent->pChildren = this;
+        pChildren = NULL;
+        if (parent) {
+            if (parent->pChildren == NULL) {
+                parent->pChildren = this;
+            }
+        } else {
         }
         if (prev) {
             while (prev->pNext) {
@@ -73,13 +77,41 @@ class cModule {
     size_t getWireCount() {
         size_t ret = 0;
         for (cModule *p = getFirstModule(); p; p = p->pNext) {
-            ret += p->pChildren->getWireCount();
+            if (p->pChildren) {
+                ret += p->pChildren->getWireCount();
+            }
             ret += p->wires.size();
         }
         return ret;
     }
 
     void printHeader(cOutput *pO, std::string prefix);
-};
 
+    cModule *searchModule(const char *pPath) {
+        const char *pSlash = strchr(pPath, '/');
+        int len = pSlash ? pSlash - pPath : strlen(pPath);
+        cModule *pRet = NULL;
+        if (pPath == pSlash) {
+            pRet = this;
+            while (pRet && pRet->pParent) {
+                pRet = pRet->pParent;
+            }
+        } else if (len == 2 && pPath[0] == '.' && pPath[1] == '.') {
+            pRet = pParent ? pParent : this;
+        } else if (len == 1 && pPath[0] == '.') {
+            pRet = this;
+        } else {
+            pRet = getFirstModule();
+            while (pRet && strncmp(pRet->getName(), pPath, len)) {
+                pRet = pRet->pNext;
+            }
+        }
+        if (pRet && pPath[len] == '/') {
+            pRet = pRet->searchModule(pPath + len + 1);
+        }
+
+        return pRet;
+    }
+};
+    
 #endif
diff --git a/src/cvcdoutput.cpp b/src/cvcdoutput.cpp
index 4fcdcd2..860a9d8 100644
--- a/src/cvcdoutput.cpp
+++ b/src/cvcdoutput.cpp
@@ -41,6 +41,7 @@ void cVCDOutput::headerStart()
 
     fprintf(pOut, "$timescale 1ps $end\n");
 }
+
 void cVCDOutput::headerSetStartTime(long long time)
 {
     fprintf(pOut, "Start time: %lld", time);
@@ -78,6 +79,8 @@ void cVCDOutput::headerEnd()
 {
     // over all wires generate the short names
     fprintf(pOut, "$enddefinitions $end\n");
+    firstTimeOff = ftell(pOut);
+    fprintf(pOut, "#0                    \n");
     fprintf(pOut, "$dumpvars\n");
 
     for (std::vector<sData *>::iterator it = items.begin(); it != items.end(); it++) {
@@ -96,9 +99,6 @@ void cVCDOutput::headerEnd()
                 *pPtr++ = ' ';
             } else {
                 *pPtr++ = 'x';
-                if (pSN[1]) {
-                    *pPtr++ = ' ';
-                }
             }
 
             while (*pSN) {
@@ -113,6 +113,15 @@ void cVCDOutput::headerEnd()
 void cVCDOutput::setTime(long long time)
 {
     flush();
+    if (0 < firstTimeOff) {
+        long currOff  = ftell(pOut);
+        if (5 < time && 0 == fseek(pOut, firstTimeOff, SEEK_SET)) {
+            fprintf(pOut, "#%lld", time - 5);
+            fseek(pOut, currOff, SEEK_SET);
+        }
+        firstTimeOff = 0;
+    }
+    lastTime = time;
     fprintf(pOut, "#%lld\n", time);
 }
 
@@ -129,17 +138,13 @@ cVCDOutput::getStringValue(cWire *pW)
     if (1 < bitLen) {
         *pPtr++ = 'b';
         for (size_t idx = bitLen; 0 < idx--; ) {
-            *pPtr++ = pVal[idx / 8] & (1 << (idx & 8)) ? one : zero;
+            *pPtr++ = pVal[idx / 8] & (1 << (idx & 7)) ? one : zero;
         }
         *pPtr++ = ' ';
     } else {
         *pPtr++ = pVal[0] & 1 ? one : zero;
-        if (pSN[1]) {
-            *pPtr++ = ' ';
-        }
     }
 
-
     while (*pSN) {
         *pPtr++ = *pSN++;
     }
@@ -155,6 +160,7 @@ void cVCDOutput::print(cWire *pW)
 
 void cVCDOutput::finish()
 {
+    fprintf(pOut, "#%lld\n", lastTime+1);
     fprintf(pOut, "DONE!!!\n");
 }
 
diff --git a/src/cvcdoutput.h b/src/cvcdoutput.h
index 42d413c..97fef10 100644
--- a/src/cvcdoutput.h
+++ b/src/cvcdoutput.h
@@ -26,21 +26,41 @@ under the License.
 #include "coutput.h"
 
 class cVCDOutput : public cOutput {
+    static const int maxRange = 127 - 33;
     size_t wireCount;
     size_t wireCountMax;
+    int wireCountChar; 
+    long   firstTimeOff;
+    long long lastTime; 
+
     const char *shortWireGenerator(char *pBuffer) {
         *--pBuffer = 0;
         size_t val = wireCount;
+
+        if (wireCountChar == 0) {
+            size_t cnt = wireCountMax;
+
+            while (cnt) {
+                cnt = cnt / maxRange;
+                wireCountChar ++;
+            }
+            wireCountChar = wireCountChar ? wireCountChar : 1;
+        }
+        int charCnt = wireCountChar;
+        
         do {
-            *--pBuffer = 33 + val % (127 - 33);
-            val /= (127 - 33);
-        } while (val != 0);
+            *--pBuffer = 33 + val % maxRange;
+            val /= maxRange;
+        } while (--charCnt);
         wireCount++;
         return pBuffer;
     }
     public:
     cVCDOutput(FILE *pO) : cOutput(pO) {
-        wireCount = 0;
+        wireCount     = 0;
+        wireCountMax  = 0;
+        firstTimeOff  = 0;
+        wireCountChar = 0;
     }
 
     virtual ~cVCDOutput();
diff --git a/test/ela.json b/test/ela.json
index e36471a..4b1bbb8 100644
--- a/test/ela.json
+++ b/test/ela.json
@@ -1,18 +1,49 @@
 
 {
 	"ELA600" : {
-		"ELA600_BF" : {
+		"ELA600_WR" : {
 			"<wire>" : {
-				"valid" : { "end" : 0, "start" : 0 },
-				"write" : { "end" : 1, "start" : 1 },
-				"addr"  : { "end" : 90, "start" : 32 }
+				"awvalid"      : { "len" :  1 },
+				"awready"      : { "len" :  1 },
+				"awid"         : { "len" :  7 },
+				"awaddr"       : { "len" : 48 },
+				"awregion"     : { "len" :  4 },
+				"awlen"        : { "len" :  8 },
+				"awsize"       : { "len" :  3 },
+				"awburst"      : { "len" :  2 },
+				"awlock"       : { "len" :  1 },
+				"awcache"      : { "len" :  4 },
+				"awprot"       : { "len" :  3 } ,
+				"awnse"        : { "len" :  1 },
+				"awqos"        : { "len" :  4 },
+				"awuser"       : { "len" :  4 },
+				"awdomain"     : { "len" :  2 },
+				"awsnoop"      : { "len" :  4 },
+				"awstashnid"   : { "len" : 11 },
+				"awstashniden" : { "len" :  1 },
+				"awstashpid"   : { "len" :  5 },
+				"awstashpiden" : { "len" :  1 },
+				"awtrace"      : { "len" :  1 },
+				"awloop"       : { "len" :  4 },
+				"awmmuvalid"   : { "len" :  1 },
+				"awmmusecid"   : { "len" :  4 },
+				"awmmusid"     : { "len" :  4 }
+			}
+		},
+		"ELA600_RD" : {
+			"<wire>" : {
+				"arraw"      : { "len" :  128 }
 			}
 		},
 		"<node>" : {
-			"CH[0]" : { "<ref>" : "ELA600_BF", "<idx>" : 0},
-			"CH[1]" : { "<ref>" : "ELA600_BF", "<idx>" : 1},
-			"CH[2]" : { "<ref>" : "ELA600_BF", "<idx>" : 2},
-			"CH[3]" : { "<ref>" : "ELA600_BF", "<idx>" : 3}
+			"TRACE[0]" : { "<ref>" : "../../ELA600_WR", "<idx>" : 0x00},
+			"TRACE[1]" : { "<ref>" : "../../ELA600_WR", "<idx>" : 0x01},
+			"TRACE[2]" : { "<ref>" : "../../ELA600_WR", "<idx>" : 0x02},
+			"TRACE[3]" : { "<ref>" : "../../ELA600_WR", "<idx>" : 0x03},
+			"TRACE[4]" : { "<ref>" : "../../ELA600_RD", "<idx>" : 0x04},
+			"TRACE[5]" : { "<ref>" : "../../ELA600_RD", "<idx>" : 0x05},
+			"TRACE[6]" : { "<ref>" : "../../ELA600_RD", "<idx>" : 0x06},
+			"TRACE[7]" : { "<ref>" : "../../ELA600_RD", "<idx>" : 0x07}
 		}
 	},
 
@@ -20,10 +51,10 @@
 		"<wire>" : { "CLOCK" : {"end" : 0, "start" : 0} }
 	},
 	"<node>" : {
-		"CLK" : { "<ref>" : "CLOCK", "<idx>" : 0 },
-		"ELA0" : { "<ref>" : "ELA600", "<idx>" : 0x1000 },
-		"ELA1" : { "<ref>" : "ELA600", "<idx>" : 0x1100 },
-		"ELA2" : { "<ref>" : "ELA600", "<idx>" : 0x1200 },
-		"ELA3" : { "<ref>" : "ELA600", "<idx>" : 0x1300 }
+		"CLK" : { "<ref>" : "/CLOCK", "<idx>" : 0 },
+		"ELA0" : { "<ref>" : "/ELA600", "<idx>" : 0x1000 },
+		"ELA1" : { "<ref>" : "/ELA600", "<idx>" : 0x1100 },
+		"ELA2" : { "<ref>" : "/ELA600", "<idx>" : 0x1200 },
+		"ELA3" : { "<ref>" : "/ELA600", "<idx>" : 0x1300 }
 	}
 }
diff --git a/test/main.cpp b/test/main.cpp
deleted file mode 100644
index 796728a..0000000
--- a/test/main.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-
-#include <stdio.h>
-
-#include "cmodule.h"
-#include "cwire.h"
-#include "cvcdoutput.h"
-#include "cjson.h"
-#include "cbitfield.h"
-
-int
-main(int argc, char **ppArgv)
-{
-    char aJsonObj[] = "[1, { \"s\" : 0x123456 }, \"asd\"]";
-    char aBuffer[64*1024];
-    int len = sizeof(aBuffer);
-
-    char *pJsonObj = aJsonObj;
-    cJSONbase *pJson = cJSONbase::generate(0, pJsonObj);
-    FILE *pIn = fopen("ela.json", "r");
-
-    cJSONbase *pJsonEla = cJSONbase::generate(0, pIn);
-
-    char *pEnd = pJson->toStr(len, aBuffer);
-    printf("In: %s -> Out: %d:%s\n", aJsonObj, len, aBuffer);
-
-    len = sizeof(aBuffer);
-    pEnd = pJsonEla->toStr(len, aBuffer);
-    printf("ELA: %d:%s\n", len, aBuffer);
-
-    cBitfield *pELA = new cBitfield(pJsonEla);
-
-#if 0 
-    cJSONscalar *pS1 = dynamic_cast<cJSONscalar *>(pJson);
-    cJSONscalar *pS2 = (cJSONscalar *) pJson ;
-    printf("%p %p\n", pS1, pS2);
-    cModule *pOne   = new cModule("ONE");
-    cModule *pTwo   = new cModule("TWO", NULL, pOne);
-    cModule *pThree = new cModule("THREE", NULL, pOne);
-    cWire *pW1, *pW2, *pW3;
-    pOne->addWire(pW1 = new cWire(WT_BITS, 1, "one"));
-    pOne->addWire(pW2 = new cWire(WT_BITS, 2, "two"));
-    pOne->addWire(pW3 = new cWire(WT_BITS, 3, "three"));
-
-    cModule *pOneOne = new cModule("ONEone", pOne);
-    new cModule("ONEtwo", pOne, pOneOne);
-    pOneOne->addWire(new cWire(WT_HEX, 64, "addr"));
-    pOneOne->addWire(new cWire(WT_HEX, 64, "data"));
-#endif
-
-    FILE *pOut = fopen("output.vcd", "w");
-    cVCDOutput output(pOut);
-
-    pELA->getFirstModule()->printHeader(&output, "");
-    
-    unsigned int clk = 0;
-    for (int tick = 0; tick < 10; tick += 1) {
-        char aBuffer[16] = { (char) tick, (char) tick, (char) tick, (char) tick, (char) tick, (char) tick};
-        output.setTime(2*tick);
-        pELA->updateValue(0, 1, (char *) &clk);
-        pELA->updateValue(0x1000, 16, aBuffer);
-
-        clk ^= 1;
-        output.setTime(2*tick + 1);
-        pELA->updateValue(0, 1, (char *) &clk);
-        clk ^= 1;
-        
-    }
-
-    output.flush();
-    fclose(pOut);
-}
\ No newline at end of file
